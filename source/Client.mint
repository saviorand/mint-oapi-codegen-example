// Mint API Client generated by github.com/oapi-codegen/oapi-codegen/v2 version v0.1.0
// DO NOT EDIT.
//
// This file provides types and client methods for interacting with the OpenAPI HTTP API.



// NewPost defines model for NewPost.
type NewPost {
  authorId : Number,
  content : String,
  title : String
}

// Post defines model for Post.
type Post {
  authorId : Number,
  content : String,
  id : Number,
  published : Maybe(Bool),
  title : String
}

// User defines model for User.
type User {
  bio : Maybe(String),
  email : String,
  id : Number,
  username : String
}



// ListPostsParams defines parameters for ListPosts.
type ListPostsParams {
  limit : Maybe(Number),
  offset : Maybe(Number)
}























// BlogApiSubscription is required for the provider (unused for HTTP client)
type BlogApiSubscription {
  dummy : String
}

// BlogApi provides HTTP client methods for the API
provider BlogApi : BlogApiSubscription {
  // The base URL of the API server
  state baseUrl : String = "https://jsonplaceholder.typicode.com"
  
  // Update function for the provider (required)
  fun update {
    void
  }

// ListPosts
  fun listPosts(params : ListPostsParams) : Promise(Result(Http.ErrorResponse, Array(Post))) {
    let queryParams =
      [
        
        Maybe.map(params.limit, (value : Number) : Tuple(String, String) { {"limit", Number.toString(value)} }),
        
        Maybe.map(params.offset, (value : Number) : Tuple(String, String) { {"offset", Number.toString(value)} })
      ]
      |> Array.compact()

    let queryString =
      if Array.isEmpty(queryParams) {
        ""
      } else {
        "?" + String.join(Array.map(queryParams, (param : Tuple(String, String)) { "#{param[0]}=#{param[1]}" }), "&")
      }

    let url =
      "#{baseUrl}/posts" + queryString

    let request =
      Http.get(url)

    let Ok(httpResponse) =
      await Http.send(request) or return Result.Err({
        headers: Map.empty(),
        type: Http.Error.NetworkError,
        status: 0,
        url: url
      })

    let JSON(object) =
      httpResponse.body or return Result.Err({
        headers: httpResponse.headers,
        type: Http.Error.NetworkError,
        status: httpResponse.status,
        url: url
      })

    decode object as Array(Post)
    |> Result.mapError((error : Object.Error) : Http.ErrorResponse {
      {
        headers: httpResponse.headers,
        type: Http.Error.NetworkError,
        status: httpResponse.status,
        url: url
      }
    })
  }

// CreatePost with body
  fun createPost(body : NewPost) : Promise(Result(Http.ErrorResponse, String)) {

    let url =
      "#{baseUrl}/posts"

    let request =
      Http.post(url)
      |> Http.jsonBody(encode body)

    let Ok(httpResponse) =
      await Http.send(request) or return Result.Err({
        headers: Map.empty(),
        type: Http.Error.NetworkError,
        status: 0,
        url: url
      })

    let JSON(object) =
      httpResponse.body or return Result.Err({
        headers: httpResponse.headers,
        type: Http.Error.NetworkError,
        status: httpResponse.status,
        url: url
      })

    decode object as String
    |> Result.mapError((error : Object.Error) : Http.ErrorResponse {
      {
        headers: httpResponse.headers,
        type: Http.Error.NetworkError,
        status: httpResponse.status,
        url: url
      }
    })
  }

// GetPost
  fun getPost(postId : Number) : Promise(Result(Http.ErrorResponse, Post)) {

    let url =
      "#{baseUrl}/posts/#{postId}"

    let request =
      Http.get(url)

    let Ok(httpResponse) =
      await Http.send(request) or return Result.Err({
        headers: Map.empty(),
        type: Http.Error.NetworkError,
        status: 0,
        url: url
      })

    let JSON(object) =
      httpResponse.body or return Result.Err({
        headers: httpResponse.headers,
        type: Http.Error.NetworkError,
        status: httpResponse.status,
        url: url
      })

    decode object as Post
    |> Result.mapError((error : Object.Error) : Http.ErrorResponse {
      {
        headers: httpResponse.headers,
        type: Http.Error.NetworkError,
        status: httpResponse.status,
        url: url
      }
    })
  }

// GetUser
  fun getUser(userId : Number) : Promise(Result(Http.ErrorResponse, User)) {

    let url =
      "#{baseUrl}/users/#{userId}"

    let request =
      Http.get(url)

    let Ok(httpResponse) =
      await Http.send(request) or return Result.Err({
        headers: Map.empty(),
        type: Http.Error.NetworkError,
        status: 0,
        url: url
      })

    let JSON(object) =
      httpResponse.body or return Result.Err({
        headers: httpResponse.headers,
        type: Http.Error.NetworkError,
        status: httpResponse.status,
        url: url
      })

    decode object as User
    |> Result.mapError((error : Object.Error) : Http.ErrorResponse {
      {
        headers: httpResponse.headers,
        type: Http.Error.NetworkError,
        status: httpResponse.status,
        url: url
      }
    })
  }


}
